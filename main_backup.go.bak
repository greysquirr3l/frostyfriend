package main

import (
	"fmt"
	"image"
	"image/color"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"gocv.io/x/gocv"
)

// IsAppRunning checks if the Whiteout Survival game is running using AppleScript
func IsAppRunning(appName string) bool {
	cmd := exec.Command("osascript", "-e", `
        tell application "System Events"
            set appList to (name of every process)
            return appList
        end tell
    `)
	out, err := cmd.Output()
	if err != nil {
		log.Printf("Error detecting application: %v", err)
		return false
	}

	log.Printf("Running apps: %s", string(out))
	return strings.Contains(strings.ToLower(string(out)), strings.ToLower(appName))
}

// LocateWindow finds the position of the application window using AppleScript
func LocateWindow(appName string) (int, int, int, int, error) {
	script := `
        tell application "System Events"
            get position of front window of application process "` + appName + `"
        end tell
    `
	cmd := exec.Command("osascript", "-e", script)
	out, err := cmd.Output()
	if err != nil {
		log.Printf("Error locating window: %v", err)
		return 0, 0, 0, 0, fmt.Errorf("Could not locate window: %v", err)
	}

	log.Printf("AppleScript Output: %s", string(out))
	var x, y int
	fmt.Sscanf(string(out), "{%d, %d}", &x, &y)

	// Simulated window size; replace with actual if necessary
	width, height := 800, 600
	log.Printf("Window found: (%d, %d) with size (%d, %d)\n", x, y, width, height)

	return x, y, width, height, nil
}

// FocusApp brings the specified application to the foreground using AppleScript
func FocusApp(appName string) {
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell application "%s" to activate`, appName))
	if err := cmd.Run(); err != nil {
		log.Printf("Error focusing application %s: %v", appName, err)
	} else {
		log.Printf("Application %s brought to foreground", appName)
	}
}

// LoadImages loads all PNG images from the images folder into a matrix
func LoadImages(folderPath string) (map[string]gocv.Mat, error) {
	images := make(map[string]gocv.Mat)

	err := filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && filepath.Ext(path) == ".png" {
			img := gocv.IMRead(path, gocv.IMReadColor)
			if img.Empty() {
				return fmt.Errorf("could not read image: %s", path)
			}
			log.Printf("Loaded image: %s", info.Name())
			images[info.Name()] = img
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	return images, nil
}

// SearchAndClick searches for an image template on the screen, clicks the center if found, and saves the result to a file.
func SearchAndClick(template gocv.Mat, screen gocv.Mat, windowX, windowY int) bool {
	result := gocv.NewMat()
	defer result.Close()

	// Log the sizes of the screen and the image for debugging
	log.Printf("Screen size: (%d, %d), Template size: (%d, %d)", screen.Cols(), screen.Rows(), template.Cols(), template.Rows())

	// Perform template matching
	gocv.MatchTemplate(screen, template, &result, gocv.TmCcoeffNormed, gocv.NewMat())

	// Find the min and max values and their locations
	_, maxVal, _, maxLoc := gocv.MinMaxLoc(result)

	if maxVal >= 0.75 {
		log.Printf("Template found with match value: %.2f at position: (%d, %d)", maxVal, maxLoc.X, maxLoc.Y)

		// Calculate the center of the matched area
		centerX := maxLoc.X + (template.Cols() / 2)
		centerY := maxLoc.Y + (template.Rows() / 2)

		// Adjust the coordinates relative to the window
		adjustedX := windowX + centerX
		adjustedY := windowY + centerY
		log.Printf("Clicking at adjusted position: (%d, %d)", adjustedX, adjustedY)

		// Draw a green rectangle around the matched area
		rect := image.Rect(maxLoc.X, maxLoc.Y, maxLoc.X+template.Cols(), maxLoc.Y+template.Rows())
		gocv.Rectangle(&screen, rect, color.RGBA{0, 255, 0, 255}, 2)

		// Draw a small green circle where the click is supposed to happen (the center of the template match)
		gocv.Circle(&screen, image.Pt(centerX, centerY), 5, color.RGBA{0, 255, 0, 255}, -1)

		// Save the result with the rectangle and green dot drawn on it
		outputFilePath := "./matched_result_with_dot.png"
		if ok := gocv.IMWrite(outputFilePath, screen); !ok {
			log.Printf("Error saving the result image to %s", outputFilePath)
			return false
		}
		log.Printf("Result with dot saved to %s", outputFilePath)

		// Simulate a click at the center of the detected area
		cmd := exec.Command("cliclick", fmt.Sprintf("c:%d,%d", adjustedX, adjustedY))
		if err := cmd.Run(); err != nil {
			log.Printf("Error performing click: %v", err)
			return false
		}
		log.Printf("Click performed at position: (%d, %d)", adjustedX, adjustedY)
		return true
	}

	log.Printf("Template not found. Max match value: %.2f", maxVal)

	// Save the screen even if no match was found for debugging
	outputFilePath := "./matched_result_nomatch.png"
	if ok := gocv.IMWrite(outputFilePath, screen); !ok {
		log.Printf("Error saving the result image to %s", outputFilePath)
	}
	log.Printf("Result without match saved to %s", outputFilePath)

	return false
}

// CaptureScreen takes a screenshot of the specified region and returns it as an OpenCV matrix
func CaptureScreen(windowX, windowY, width, height int) gocv.Mat {
	// Focus the application window before performing the screenshot
	FocusApp("whiteoutsurvival") // Ensure the app name is correct

	// Add a longer delay to ensure the app has time to come to the front
	time.Sleep(1000 * time.Millisecond) // Increased to 1 second

	// Log the coordinates and dimensions to help
	// Log the coordinates and dimensions to help with debugging
	log.Printf("Capturing screen at: (%d, %d), size: (%d, %d)", windowX, windowY, width, height)

	// Take a screenshot of the specified region using macOS's screencapture utility
	cmd := exec.Command("screencapture", "-R", fmt.Sprintf("%d,%d,%d,%d", windowX, windowY, width, height), "/tmp/screenshot.png")
	err := cmd.Run()
	if err != nil {
		log.Printf("Error capturing screen: %v", err)
		return gocv.NewMat()
	}

	// Load the captured screenshot into OpenCV
	img := gocv.IMRead("/tmp/screenshot.png", gocv.IMReadColor)
	if img.Empty() {
		log.Println("Failed to load screenshot")
	}

	return img
}
