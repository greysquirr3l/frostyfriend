package main

import (
	"flag"
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"image"
	"image/color"

	"gocv.io/x/gocv"
)

// Global variables
var (
	debugMode   bool
	logChan     = make(chan string, 100)
	totalClicks int
)

type ClickTarget struct {
	Name string
	X    float64 // Percentage of window width
	Y    float64 // Percentage of window height
}

var clickTarget = ClickTarget{
	Name: "Handshake",
	X:    1.40,
	Y:    1.78,
}

func logRoutine() {
	for logMsg := range logChan {
		log.Printf("%s - %s", time.Now().Format("15:04:05"), logMsg)
	}
}

func IsAppRunningAndLocateWindow(appName string) (bool, int, int, int, int, error) {
	script := fmt.Sprintf(`
        tell application "System Events"
            set appList to (name of every process where background only is false)
            if "%s" is in appList then
                tell process "%s"
                    try
                        set appWindow to first window
                        set {x, y} to position of appWindow
                        set {width, height} to size of appWindow
                        return "true," & x & "," & y & "," & width & "," & height
                    on error errMsg
                        return "false,error," & errMsg
                    end try
                end tell
            else
                return "false,app_not_running"
            end if
        end tell
    `, appName, appName)

	cmd := exec.Command("osascript", "-e", script)
	out, err := cmd.Output()
	if err != nil {
		return false, 0, 0, 0, 0, fmt.Errorf("AppleScript execution failed: %v", err)
	}

	output := strings.TrimSpace(string(out))
	if strings.HasPrefix(output, "false") {
		parts := strings.Split(output, ",")
		if len(parts) > 1 && parts[1] == "error" {
			return false, 0, 0, 0, 0, fmt.Errorf("AppleScript error: %s", strings.Join(parts[2:], ","))
		}
		return false, 0, 0, 0, 0, nil
	}

	parts := strings.Split(output, ",")
	if len(parts) != 5 {
		return false, 0, 0, 0, 0, fmt.Errorf("unexpected output format: %s", output)
	}

	x, _ := strconv.Atoi(strings.TrimSpace(parts[1]))
	y, _ := strconv.Atoi(strings.TrimSpace(parts[2]))
	width, _ := strconv.Atoi(strings.TrimSpace(parts[3]))
	height, _ := strconv.Atoi(strings.TrimSpace(parts[4]))

	return true, x, y, width, height, nil
}

func FocusApp(appName string) {
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell application "%s" to activate`, appName))
	if err := cmd.Run(); err != nil {
		logChan <- fmt.Sprintf("Error focusing application %s: %v", appName, err)
	}
}

func CaptureScreen(windowX, windowY, width, height int, screenChan chan gocv.Mat, wg *sync.WaitGroup) {
	defer wg.Done()
	outputPath := "/tmp/screenshot.png"

	if width <= 0 || height <= 0 {
		logChan <- fmt.Sprintf("Invalid dimensions: width=%d, height=%d", width, height)
		screenChan <- gocv.NewMat()
		return
	}

	time.Sleep(100 * time.Millisecond)

	cmd := exec.Command("screencapture", "-x", "-R", fmt.Sprintf("%d,%d,%d,%d", windowX, windowY, width, height), outputPath)
	if err := cmd.Run(); err != nil {
		logChan <- fmt.Sprintf("Error capturing screen: %v", err)
		screenChan <- gocv.NewMat()
		return
	}

	info, err := os.Stat(outputPath)
	if err != nil || info.Size() == 0 {
		logChan <- "Screenshot file is empty or does not exist"
		screenChan <- gocv.NewMat()
		return
	}

	img := gocv.IMRead(outputPath, gocv.IMReadColor)
	if img.Empty() {
		logChan <- "Failed to load screenshot"
		screenChan <- gocv.NewMat()
		return
	}

	screenChan <- img
}

func SearchAndClick(template gocv.Mat, screen gocv.Mat, windowX, windowY, windowWidth, windowHeight int, targetName string) bool {
	if template.Empty() || screen.Empty() {
		logChan <- fmt.Sprintf("Empty template or screen for %s", targetName)
		return false
	}

	if template.Cols() > screen.Cols() || template.Rows() > screen.Rows() {
		logChan <- fmt.Sprintf("Template larger than screen for %s", targetName)
		return false
	}

	result := gocv.NewMat()
	defer result.Close()

	gocv.MatchTemplate(screen, template, &result, gocv.TmCcoeffNormed, gocv.NewMat())

	_, maxVal, _, maxLoc := gocv.MinMaxLoc(result)

	var threshold float32 = 0.65
	if targetName == "big_x" {
		threshold = 0.75
	}

	if maxVal >= threshold {
		centerX := maxLoc.X + (template.Cols() / 2)
		centerY := maxLoc.Y + (template.Rows() / 2)

		scaleX := float64(windowWidth) / float64(screen.Cols())
		scaleY := float64(windowHeight) / float64(screen.Rows())

		adjustedX := windowX + int(float64(centerX)*scaleX)
		adjustedY := windowY + int(float64(centerY)*scaleY)

		adjustedX += rand.Intn(3) - 1
		adjustedY += rand.Intn(3) - 1

		if debugMode {
			debugScreen := screen.Clone()
			defer debugScreen.Close()

			rect := image.Rect(maxLoc.X, maxLoc.Y, maxLoc.X+template.Cols(), maxLoc.Y+template.Rows())
			gocv.Rectangle(&debugScreen, rect, color.RGBA{0, 255, 0, 0}, 2)
			gocv.Circle(&debugScreen, image.Pt(centerX, centerY), 5, color.RGBA{255, 0, 0, 0}, -1)

			debugPath := fmt.Sprintf("/tmp/%s-debug-%d.png", targetName, time.Now().Unix())
			if ok := gocv.IMWrite(debugPath, debugScreen); !ok {
				logChan <- fmt.Sprintf("Error saving debug screenshot: %s", debugPath)
			} else {
				logChan <- fmt.Sprintf("Debug screenshot saved: %s", debugPath)
			}
		}

		time.Sleep(50 * time.Millisecond)

		cmd := exec.Command("cliclick", fmt.Sprintf("c:%d,%d", adjustedX, adjustedY))
		if err := cmd.Run(); err != nil {
			logChan <- fmt.Sprintf("Error performing click: %v", err)
			return false
		}

		totalClicks++
		logChan <- fmt.Sprintf("Click performed on %s at (%d, %d) (Total clicks: %d, Confidence: %.2f)",
			targetName, adjustedX, adjustedY, totalClicks, maxVal)
		return true
	}

	logChan <- fmt.Sprintf("No match found for %s (Best match: %.2f)", targetName, maxVal)
	return false
}

func main() {
	iterationDelay := flag.Int("delay", 10, "Delay between iterations in seconds")
	randomDelay := flag.Bool("random", false, "Use random delay")
	iterationCount := flag.Int("iterations", 0, "Number of iterations (0 for infinite)")
	helpFlag := flag.Bool("help", false, "Display help information")
	flag.BoolVar(&debugMode, "debug", false, "Enable debug mode")

	flag.Parse()

	if *helpFlag {
		flag.Usage()
		os.Exit(0)
	}

	log.SetOutput(os.Stdout)
	go logRoutine()

	logChan <- "Starting Whiteout Survival helper"

	signalChannel := make(chan os.Signal, 1)
	signal.Notify(signalChannel, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-signalChannel
		logChan <- "Shutting down..."
		close(logChan)
		os.Exit(0)
	}()

	handshakeTemplate := gocv.IMRead(filepath.Join("images", "handshake_icon.png"), gocv.IMReadColor)
	defer handshakeTemplate.Close()

	bigXTemplate := gocv.IMRead(filepath.Join("images", "big_x.png"), gocv.IMReadColor)
	defer bigXTemplate.Close()

	screenChan := make(chan gocv.Mat, 1)
	var wg sync.WaitGroup

	for *iterationCount == 0 || totalClicks < *iterationCount {
		isRunning, x, y, width, height, err := IsAppRunningAndLocateWindow("whiteoutsurvival")
		if err != nil || !isRunning {
			logChan <- "Application not running or error occurred"
			time.Sleep(time.Duration(*iterationDelay) * time.Second)
			continue
		}

		FocusApp("WhiteoutSurvival")
		wg.Add(1)
		go CaptureScreen(x, y, width, height, screenChan, &wg)

		wg.Wait()
		screen := <-screenChan
		if screen.Empty() {
			logChan <- "No valid screenshot received"
			continue
		}

		SearchAndClick(bigXTemplate, screen, x, y, width, height, "big_x")
		SearchAndClick(handshakeTemplate, screen, x, y, width, height, "handshake_icon")

		screen.Close()

		delay := time.Duration(*iterationDelay) * time.Second
		if *randomDelay {
			delay = time.Duration(rand.Intn(*iterationDelay)) * time.Second
		}
		logChan <- fmt.Sprintf("Waiting for %v before next iteration", delay)
		time.Sleep(delay)
	}
}
